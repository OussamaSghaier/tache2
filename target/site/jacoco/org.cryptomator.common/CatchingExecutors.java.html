<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CatchingExecutors.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cryptomator Desktop App</a> &gt; <a href="index.source.html" class="el_package">org.cryptomator.common</a> &gt; <span class="el_source">CatchingExecutors.java</span></div><h1>CatchingExecutors.java</h1><pre class="source lang-java linenums">package org.cryptomator.common;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javafx.application.Platform;
import javafx.concurrent.Task;
import java.util.Objects;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

//Inspired by: https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/ThreadPoolExecutor.html#afterExecute(java.lang.Runnable,java.lang.Throwable)
public final class CatchingExecutors {

<span class="nc" id="L22">	private static final Logger LOG = LoggerFactory.getLogger(CatchingExecutors.class);</span>

	private CatchingExecutors() { /* NO-OP */ }

	public static class CatchingScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {

		public CatchingScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {
<span class="nc" id="L29">			super(corePoolSize, threadFactory);</span>
<span class="nc" id="L30">		}</span>

		@Override
		public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
<span class="nc" id="L34">			Runnable oneShot = () -&gt; this.execute(command);</span>
<span class="nc" id="L35">			return super.scheduleAtFixedRate(oneShot, initialDelay, period, unit);</span>
		}

		@Override
		public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
<span class="nc" id="L40">			Runnable oneShot = () -&gt; this.execute(command);</span>
<span class="nc" id="L41">			return super.scheduleWithFixedDelay(oneShot, initialDelay, delay, unit);</span>
		}

		@Override
		protected void afterExecute(Runnable runnable, Throwable throwable) {
<span class="nc" id="L46">			super.afterExecute(runnable, throwable);</span>
<span class="nc" id="L47">			afterExecuteInternal(runnable, throwable);</span>
<span class="nc" id="L48">		}</span>
	}

	public static class CatchingThreadPoolExecutor extends ThreadPoolExecutor {

		public CatchingThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) {
<span class="nc" id="L54">			super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);</span>
<span class="nc" id="L55">		}</span>

		@Override
		protected void afterExecute(Runnable runnable, Throwable throwable) {
<span class="nc" id="L59">			super.afterExecute(runnable, throwable);</span>
<span class="nc" id="L60">			afterExecuteInternal(runnable, throwable);</span>
<span class="nc" id="L61">		}</span>
	}

	private static void afterExecuteInternal(Runnable runnable, Throwable throwable) {
<span class="nc bnc" id="L65" title="All 2 branches missed.">		if (throwable != null) {</span>
<span class="nc" id="L66">			callHandler(Thread.currentThread(), throwable);</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">		} else if (runnable instanceof Task&lt;?&gt; t) {</span>
<span class="nc" id="L68">			afterExecuteTask(t);</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">		} else if (runnable instanceof Future&lt;?&gt; f) {</span>
<span class="nc" id="L70">			afterExecuteFuture(f);</span>
		}
		//Errors in this method are delegated to the UncaughtExceptionHandler of the current thread
<span class="nc" id="L73">	}</span>

	private static void callHandler(Thread thread, Throwable throwable) {
<span class="nc" id="L76">		Objects.requireNonNullElseGet(thread.getUncaughtExceptionHandler(), CatchingExecutors::fallbackHandler).uncaughtException(thread, throwable);</span>
<span class="nc" id="L77">	}</span>

	private static Thread.UncaughtExceptionHandler fallbackHandler() {
<span class="nc" id="L80">		return (thread, throwable) -&gt; LOG.error(&quot;FALLBACK: Uncaught exception in &quot; + thread.getName(), throwable);</span>
	}

	private static void afterExecuteTask(Task&lt;?&gt; task) {
<span class="nc" id="L84">		var caller = Thread.currentThread();</span>
<span class="nc" id="L85">		Platform.runLater(() -&gt; {</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">			if (task.getOnFailed() == null) {</span>
<span class="nc" id="L87">				callHandler(caller, task.getException());</span>
			}
<span class="nc" id="L89">		});</span>
<span class="nc" id="L90">	}</span>

	private static void afterExecuteFuture(Future&lt;?&gt; future) {
<span class="nc bnc" id="L93" title="All 4 branches missed.">		if (future instanceof ScheduledFuture&lt;?&gt; &amp;&amp; !future.isDone()) {</span>
			//we assume that this must be a repeated ScheduledFutureTask, where the done-status is only set when not executed anymore
			//see also https://github.com/cryptomator/cryptomator/pull/2422
<span class="nc" id="L96">			return;</span>
		}

		try {
<span class="nc" id="L100">			future.get();</span>
<span class="nc" id="L101">		} catch (CancellationException ce) {</span>
			//Ignore
<span class="nc" id="L103">		} catch (ExecutionException ee) {</span>
<span class="nc" id="L104">			callHandler(Thread.currentThread(), ee.getCause());</span>
<span class="nc" id="L105">		} catch (InterruptedException ie) {</span>
			//Ignore/Reset
<span class="nc" id="L107">			Thread.currentThread().interrupt();</span>
<span class="nc" id="L108">		}</span>
<span class="nc" id="L109">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>