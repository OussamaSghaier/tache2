<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Vault.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cryptomator Desktop App</a> &gt; <a href="index.source.html" class="el_package">org.cryptomator.common.vaults</a> &gt; <span class="el_source">Vault.java</span></div><h1>Vault.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2016, 2017 Sebastian Stenzel and others.
 * All rights reserved.
 * This program and the accompanying materials are made available under the terms of the accompanying LICENSE file.
 *
 * Contributors:
 *     Sebastian Stenzel - initial API and implementation
 *******************************************************************************/
package org.cryptomator.common.vaults;

import org.apache.commons.lang3.SystemUtils;
import org.cryptomator.common.Constants;
import org.cryptomator.common.mount.Mounter;
import org.cryptomator.common.settings.Settings;
import org.cryptomator.common.settings.VaultSettings;
import org.cryptomator.cryptofs.CryptoFileSystem;
import org.cryptomator.cryptofs.CryptoFileSystemProperties;
import org.cryptomator.cryptofs.CryptoFileSystemProperties.FileSystemFlags;
import org.cryptomator.cryptofs.CryptoFileSystemProvider;
import org.cryptomator.cryptofs.common.FileSystemCapabilityChecker;
import org.cryptomator.cryptolib.api.CryptoException;
import org.cryptomator.cryptolib.api.MasterkeyLoader;
import org.cryptomator.cryptolib.api.MasterkeyLoadingFailedException;
import org.cryptomator.integrations.mount.MountFailedException;
import org.cryptomator.integrations.mount.Mountpoint;
import org.cryptomator.integrations.mount.UnmountFailedException;
import org.cryptomator.integrations.quickaccess.QuickAccessService;
import org.cryptomator.integrations.quickaccess.QuickAccessServiceException;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import javax.inject.Named;
import javafx.beans.Observable;
import javafx.beans.binding.Bindings;
import javafx.beans.binding.BooleanBinding;
import javafx.beans.binding.ObjectBinding;
import javafx.beans.binding.StringBinding;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyStringProperty;
import javafx.beans.property.SimpleBooleanProperty;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.EnumSet;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.atomic.AtomicReference;

@PerVault
public class Vault {

<span class="fc" id="L55">	private static final Logger LOG = LoggerFactory.getLogger(Vault.class);</span>
<span class="fc" id="L56">	private static final Path HOME_DIR = Paths.get(SystemUtils.USER_HOME);</span>
	private static final int UNLIMITED_FILENAME_LENGTH = Integer.MAX_VALUE;

	private final VaultSettings vaultSettings;
	private final AtomicReference&lt;CryptoFileSystem&gt; cryptoFileSystem;
	private final AtomicReference&lt;QuickAccessService.QuickAccessEntry&gt; quickAccessEntry;
	private final VaultState state;
	private final ObjectProperty&lt;Exception&gt; lastKnownException;
	private final VaultConfigCache configCache;
	private final VaultStats stats;
	private final StringBinding displayablePath;
	private final BooleanBinding locked;
	private final BooleanBinding processing;
	private final BooleanBinding unlocked;
	private final BooleanBinding missing;
	private final BooleanBinding needsMigration;
	private final BooleanBinding unknownError;
	private final ObjectBinding&lt;Mountpoint&gt; mountPoint;
	private final Mounter mounter;
	private final Settings settings;
	private final BooleanProperty showingStats;

<span class="nc" id="L78">	private final AtomicReference&lt;Mounter.MountHandle&gt; mountHandle = new AtomicReference&lt;&gt;(null);</span>

	@Inject
	Vault(VaultSettings vaultSettings, //
		  VaultConfigCache configCache, //
		  AtomicReference&lt;CryptoFileSystem&gt; cryptoFileSystem, //
		  VaultState state, //
		  @Named(&quot;lastKnownException&quot;) ObjectProperty&lt;Exception&gt; lastKnownException, //
		  VaultStats stats, //
<span class="nc" id="L87">		  Mounter mounter, Settings settings) {</span>
<span class="nc" id="L88">		this.vaultSettings = vaultSettings;</span>
<span class="nc" id="L89">		this.configCache = configCache;</span>
<span class="nc" id="L90">		this.cryptoFileSystem = cryptoFileSystem;</span>
<span class="nc" id="L91">		this.state = state;</span>
<span class="nc" id="L92">		this.lastKnownException = lastKnownException;</span>
<span class="nc" id="L93">		this.stats = stats;</span>
<span class="nc" id="L94">		this.displayablePath = Bindings.createStringBinding(this::getDisplayablePath, vaultSettings.path);</span>
<span class="nc" id="L95">		this.locked = Bindings.createBooleanBinding(this::isLocked, state);</span>
<span class="nc" id="L96">		this.processing = Bindings.createBooleanBinding(this::isProcessing, state);</span>
<span class="nc" id="L97">		this.unlocked = Bindings.createBooleanBinding(this::isUnlocked, state);</span>
<span class="nc" id="L98">		this.missing = Bindings.createBooleanBinding(this::isMissing, state);</span>
<span class="nc" id="L99">		this.needsMigration = Bindings.createBooleanBinding(this::isNeedsMigration, state);</span>
<span class="nc" id="L100">		this.unknownError = Bindings.createBooleanBinding(this::isUnknownError, state);</span>
<span class="nc" id="L101">		this.mountPoint = Bindings.createObjectBinding(this::getMountPoint, state);</span>
<span class="nc" id="L102">		this.mounter = mounter;</span>
<span class="nc" id="L103">		this.settings = settings;</span>
<span class="nc" id="L104">		this.showingStats = new SimpleBooleanProperty(false);</span>
<span class="nc" id="L105">		this.quickAccessEntry = new AtomicReference&lt;&gt;(null);</span>
<span class="nc" id="L106">	}</span>

	// ******************************************************************************
	// Commands
	// ********************************************************************************/

	private CryptoFileSystem createCryptoFileSystem(MasterkeyLoader keyLoader) throws IOException, MasterkeyLoadingFailedException {
<span class="nc" id="L113">		Set&lt;FileSystemFlags&gt; flags = EnumSet.noneOf(FileSystemFlags.class);</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">		if (vaultSettings.usesReadOnlyMode.get()) {</span>
<span class="nc" id="L115">			flags.add(FileSystemFlags.READONLY);</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">		} else if (vaultSettings.maxCleartextFilenameLength.get() == -1) {</span>
<span class="nc" id="L117">			LOG.debug(&quot;Determining cleartext filename length limitations...&quot;);</span>
<span class="nc" id="L118">			var checker = new FileSystemCapabilityChecker();</span>
<span class="nc" id="L119">			int shorteningThreshold = configCache.get().allegedShorteningThreshold();</span>
<span class="nc" id="L120">			int ciphertextLimit = checker.determineSupportedCiphertextFileNameLength(getPath());</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">			if (ciphertextLimit &lt; shorteningThreshold) {</span>
<span class="nc" id="L122">				int cleartextLimit = checker.determineSupportedCleartextFileNameLength(getPath());</span>
<span class="nc" id="L123">				vaultSettings.maxCleartextFilenameLength.set(cleartextLimit);</span>
<span class="nc" id="L124">			} else {</span>
<span class="nc" id="L125">				vaultSettings.maxCleartextFilenameLength.setValue(UNLIMITED_FILENAME_LENGTH);</span>
			}
		}

<span class="nc bnc" id="L129" title="All 2 branches missed.">		if (vaultSettings.maxCleartextFilenameLength.get() &lt; UNLIMITED_FILENAME_LENGTH) {</span>
<span class="nc" id="L130">			LOG.warn(&quot;Limiting cleartext filename length on this device to {}.&quot;, vaultSettings.maxCleartextFilenameLength.get());</span>
		}

<span class="nc" id="L133">		CryptoFileSystemProperties fsProps = CryptoFileSystemProperties.cryptoFileSystemProperties() //</span>
<span class="nc" id="L134">				.withKeyLoader(keyLoader) //</span>
<span class="nc" id="L135">				.withFlags(flags) //</span>
<span class="nc" id="L136">				.withMaxCleartextNameLength(vaultSettings.maxCleartextFilenameLength.get()) //</span>
<span class="nc" id="L137">				.withVaultConfigFilename(Constants.VAULTCONFIG_FILENAME) //</span>
<span class="nc" id="L138">				.build();</span>
<span class="nc" id="L139">		return CryptoFileSystemProvider.newFileSystem(getPath(), fsProps);</span>
	}

	private void destroyCryptoFileSystem() {
<span class="nc" id="L143">		LOG.trace(&quot;Trying to close associated CryptoFS...&quot;);</span>
<span class="nc" id="L144">		CryptoFileSystem fs = cryptoFileSystem.getAndSet(null);</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">		if (fs != null) {</span>
			try {
<span class="nc" id="L147">				fs.close();</span>
<span class="nc" id="L148">			} catch (IOException e) {</span>
<span class="nc" id="L149">				LOG.error(&quot;Error closing file system.&quot;, e);</span>
<span class="nc" id="L150">			}</span>
		}
<span class="nc" id="L152">	}</span>

	public synchronized void unlock(MasterkeyLoader keyLoader) throws CryptoException, IOException, MountFailedException {
<span class="nc bnc" id="L155" title="All 2 branches missed.">		if (cryptoFileSystem.get() != null) {</span>
<span class="nc" id="L156">			throw new IllegalStateException(&quot;Already unlocked.&quot;);</span>
		}
<span class="nc" id="L158">		CryptoFileSystem fs = createCryptoFileSystem(keyLoader);</span>
<span class="nc" id="L159">		boolean success = false;</span>
		try {
<span class="nc" id="L161">			cryptoFileSystem.set(fs);</span>
<span class="nc" id="L162">			var rootPath = fs.getRootDirectories().iterator().next();</span>
<span class="nc" id="L163">			var mountHandle = mounter.mount(vaultSettings, rootPath);</span>
<span class="nc" id="L164">			success = this.mountHandle.compareAndSet(null, mountHandle);</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">			if (settings.useQuickAccess.getValue()) {</span>
<span class="nc" id="L166">				addToQuickAccess();</span>
			}
		} finally {
<span class="nc bnc" id="L169" title="All 2 branches missed.">			if (!success) {</span>
<span class="nc" id="L170">				destroyCryptoFileSystem();</span>
			}
		}
<span class="nc" id="L173">	}</span>

	public synchronized void lock(boolean forced) throws UnmountFailedException, IOException {
<span class="nc" id="L176">		var mountHandle = this.mountHandle.get();</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">		if (mountHandle == null) {</span>
			//TODO: noop or InvalidStateException?
<span class="nc" id="L179">			return;</span>
		}

<span class="nc bnc" id="L182" title="All 4 branches missed.">		if (forced &amp;&amp; mountHandle.supportsUnmountForced()) {</span>
<span class="nc" id="L183">			mountHandle.mountObj().unmountForced();</span>
		} else {
<span class="nc" id="L185">			mountHandle.mountObj().unmount();</span>
		}

		try {
<span class="nc" id="L189">			mountHandle.mountObj().close();</span>
<span class="nc" id="L190">			mountHandle.specialCleanup().run();</span>
		} finally {
<span class="nc" id="L192">			removeFromQuickAccess();</span>
<span class="nc" id="L193">			destroyCryptoFileSystem();</span>
		}

<span class="nc" id="L196">		this.mountHandle.set(null);</span>
<span class="nc" id="L197">		LOG.info(&quot;Locked vault '{}'&quot;, getDisplayName());</span>
<span class="nc" id="L198">	}</span>

	private synchronized void addToQuickAccess() {
<span class="nc bnc" id="L201" title="All 2 branches missed.">		if (quickAccessEntry.get() != null) {</span>
			//we don't throw an exception since we don't wanna block unlocking
<span class="nc" id="L203">			LOG.warn(&quot;Vault already added to quick access area. Will be removed on next lock operation.&quot;);</span>
<span class="nc" id="L204">			return;</span>
		}

<span class="nc" id="L207">		QuickAccessService.get() //</span>
<span class="nc" id="L208">				.filter(s -&gt; s.getClass().getName().equals(settings.quickAccessService.getValue())) //</span>
<span class="nc" id="L209">				.findFirst() //</span>
<span class="nc" id="L210">				.ifPresentOrElse( //</span>
						this::addToQuickAccessInternal, //
<span class="nc" id="L212">						() -&gt; LOG.warn(&quot;Unable to add Vault to quick access area: Desired implementation not available.&quot;) //</span>
				);
<span class="nc" id="L214">	}</span>

	private void addToQuickAccessInternal(@NotNull QuickAccessService s) {
<span class="nc bnc" id="L217" title="All 2 branches missed.">		if (getMountPoint() instanceof Mountpoint.WithPath mp) {</span>
			try {
<span class="nc" id="L219">				var entry = s.add(mp.path(), getDisplayName());</span>
<span class="nc" id="L220">				quickAccessEntry.set(entry);</span>
<span class="nc" id="L221">			} catch (QuickAccessServiceException e) {</span>
<span class="nc" id="L222">				LOG.error(&quot;Adding vault to quick access area failed&quot;, e);</span>
<span class="nc" id="L223">			}</span>
		} else {
<span class="nc" id="L225">			LOG.warn(&quot;Unable to add vault to quick access area: Vault is not mounted to local system path.&quot;);</span>
		}
<span class="nc" id="L227">	}</span>

	private synchronized void removeFromQuickAccess() {
<span class="nc bnc" id="L230" title="All 2 branches missed.">		if (quickAccessEntry.get() == null) {</span>
<span class="nc" id="L231">			LOG.debug(&quot;Removing vault from quick access area: Entry not found, nothing to do.&quot;);</span>
<span class="nc" id="L232">			return;</span>
		}
<span class="nc" id="L234">		removeFromQuickAccessInternal();</span>
<span class="nc" id="L235">	}</span>

	private void removeFromQuickAccessInternal() {
		try {
<span class="nc" id="L239">			quickAccessEntry.get().remove();</span>
<span class="nc" id="L240">			quickAccessEntry.set(null);</span>
<span class="nc" id="L241">		} catch (QuickAccessServiceException e) {</span>
<span class="nc" id="L242">			LOG.error(&quot;Removing vault from quick access area failed&quot;, e);</span>
<span class="nc" id="L243">		}</span>
<span class="nc" id="L244">	}</span>

	// ******************************************************************************
	// Observable Properties
	// *******************************************************************************

	public VaultState stateProperty() {
<span class="nc" id="L251">		return state;</span>
	}

	public VaultState.Value getState() {
<span class="nc" id="L255">		return state.getValue();</span>
	}

	public ObjectProperty&lt;Exception&gt; lastKnownExceptionProperty() {
<span class="nc" id="L259">		return lastKnownException;</span>
	}

	public Exception getLastKnownException() {
<span class="nc" id="L263">		return lastKnownException.get();</span>
	}

	public void setLastKnownException(Exception e) {
<span class="nc" id="L267">		lastKnownException.setValue(e);</span>
<span class="nc" id="L268">	}</span>

	public BooleanBinding lockedProperty() {
<span class="nc" id="L271">		return locked;</span>
	}

	public boolean isLocked() {
<span class="nc bnc" id="L275" title="All 2 branches missed.">		return state.get() == VaultState.Value.LOCKED;</span>
	}

	public BooleanBinding processingProperty() {
<span class="nc" id="L279">		return processing;</span>
	}

	public boolean isProcessing() {
<span class="nc bnc" id="L283" title="All 2 branches missed.">		return state.get() == VaultState.Value.PROCESSING;</span>
	}

	public BooleanBinding unlockedProperty() {
<span class="nc" id="L287">		return unlocked;</span>
	}

	public boolean isUnlocked() {
<span class="nc bnc" id="L291" title="All 2 branches missed.">		return state.get() == VaultState.Value.UNLOCKED;</span>
	}

	public BooleanBinding missingProperty() {
<span class="nc" id="L295">		return missing;</span>
	}

	public boolean isMissing() {
<span class="nc bnc" id="L299" title="All 2 branches missed.">		return state.get() == VaultState.Value.MISSING;</span>
	}

	public BooleanBinding needsMigrationProperty() {
<span class="nc" id="L303">		return needsMigration;</span>
	}

	public boolean isNeedsMigration() {
<span class="nc bnc" id="L307" title="All 2 branches missed.">		return state.get() == VaultState.Value.NEEDS_MIGRATION;</span>
	}

	public BooleanBinding unknownErrorProperty() {
<span class="nc" id="L311">		return unknownError;</span>
	}

	public boolean isUnknownError() {
<span class="nc bnc" id="L315" title="All 2 branches missed.">		return state.get() == VaultState.Value.ERROR;</span>
	}

	public ReadOnlyStringProperty displayNameProperty() {
<span class="nc" id="L319">		return vaultSettings.displayName;</span>
	}

	public String getDisplayName() {
<span class="nc" id="L323">		return vaultSettings.displayName.get();</span>
	}

	public ObjectBinding&lt;Mountpoint&gt; mountPointProperty() {
<span class="nc" id="L327">		return mountPoint;</span>
	}

	public Mountpoint getMountPoint() {
<span class="nc" id="L331">		var handle = mountHandle.get();</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">		return handle == null ? null : handle.mountObj().getMountpoint();</span>
	}

	public StringBinding displayablePathProperty() {
<span class="nc" id="L336">		return displayablePath;</span>
	}

	public String getDisplayablePath() {
<span class="nc" id="L340">		Path p = vaultSettings.path.get();</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">		if (p.startsWith(HOME_DIR)) {</span>
<span class="nc" id="L342">			Path relativePath = HOME_DIR.relativize(p);</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">			String homePrefix = SystemUtils.IS_OS_WINDOWS ? &quot;~\\&quot; : &quot;~/&quot;;</span>
<span class="nc" id="L344">			return homePrefix + relativePath.toString();</span>
		} else {
<span class="nc" id="L346">			return p.toString();</span>
		}
	}

	public BooleanProperty showingStatsProperty() {
<span class="nc" id="L351">		return showingStats;</span>
	}

	public boolean isShowingStats() {
<span class="nc bnc" id="L355" title="All 2 branches missed.">		return mountHandle.get() != null;</span>
	}


	// ******************************************************************************
	// Getter/Setter
	// *******************************************************************************/

	public VaultStats getStats() {
<span class="nc" id="L364">		return stats;</span>
	}


	public Observable[] observables() {
<span class="nc" id="L369">		return new Observable[]{state};</span>
	}

	public VaultSettings getVaultSettings() {
<span class="nc" id="L373">		return vaultSettings;</span>
	}

	public Path getPath() {
<span class="nc" id="L377">		return vaultSettings.path.get();</span>
	}

	/**
	 * Gets from the cleartext path its ciphertext counterpart.
	 *
	 * @return Local os path to the ciphertext resource
	 * @throws IOException if an I/O error occurs
	 * @throws IllegalStateException if the vault is not unlocked
	 */
	public Path getCiphertextPath(Path cleartextPath) throws IOException {
<span class="nc bnc" id="L388" title="All 2 branches missed.">		if (!state.getValue().equals(VaultState.Value.UNLOCKED)) {</span>
<span class="nc" id="L389">			throw new IllegalStateException(&quot;Vault is not unlocked&quot;);</span>
		}
<span class="nc" id="L391">		var fs = cryptoFileSystem.get();</span>
<span class="nc" id="L392">		var osPathSeparator = cleartextPath.getFileSystem().getSeparator();</span>
<span class="nc" id="L393">		var cryptoFsPathSeparator = fs.getSeparator();</span>

<span class="nc bnc" id="L395" title="All 2 branches missed.">		if (getMountPoint() instanceof Mountpoint.WithPath mp) {</span>
<span class="nc" id="L396">			var absoluteCryptoFsPath = cryptoFsPathSeparator + mp.path().relativize(cleartextPath).toString();</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">			if (!cryptoFsPathSeparator.equals(osPathSeparator)) {</span>
<span class="nc" id="L398">				absoluteCryptoFsPath = absoluteCryptoFsPath.replace(osPathSeparator, cryptoFsPathSeparator);</span>
			}
<span class="nc" id="L400">			var cryptoPath = fs.getPath(absoluteCryptoFsPath);</span>
<span class="nc" id="L401">			return fs.getCiphertextPath(cryptoPath);</span>
		} else {
<span class="nc" id="L403">			throw new UnsupportedOperationException(&quot;URI mount points not supported.&quot;);</span>
		}
	}

	public VaultConfigCache getVaultConfigCache() {
<span class="nc" id="L408">		return configCache;</span>
	}

	public String getId() {
<span class="nc" id="L412">		return vaultSettings.id;</span>
	}

	// ******************************************************************************
	// Hashcode / Equals
	// *******************************************************************************/

	@Override
	public int hashCode() {
<span class="nc" id="L421">		return Objects.hash(vaultSettings);</span>
	}

	@Override
	public boolean equals(Object obj) {
<span class="nc bnc" id="L426" title="All 4 branches missed.">		if (obj instanceof Vault other &amp;&amp; obj.getClass().equals(this.getClass())) {</span>
<span class="nc" id="L427">			return Objects.equals(this.vaultSettings, other.vaultSettings);</span>
		} else {
<span class="nc" id="L429">			return false;</span>
		}
	}

	public boolean supportsForcedUnmount() {
<span class="nc" id="L434">		var mh = mountHandle.get();</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">		if (mh == null) {</span>
<span class="nc" id="L436">			throw new IllegalStateException(&quot;Vault is not mounted&quot;);</span>
		}
<span class="nc" id="L438">		return mountHandle.get().supportsUnmountForced();</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>