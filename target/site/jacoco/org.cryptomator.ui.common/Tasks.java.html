<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Tasks.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cryptomator Desktop App</a> &gt; <a href="index.source.html" class="el_package">org.cryptomator.ui.common</a> &gt; <span class="el_source">Tasks.java</span></div><h1>Tasks.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2018 Skymatic UG (haftungsbeschr√§nkt).
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the accompanying LICENSE file.
 *******************************************************************************/
package org.cryptomator.ui.common;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javafx.application.Platform;
import javafx.concurrent.ScheduledService;
import javafx.concurrent.Task;
import javafx.util.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import java.util.function.Supplier;

<span class="nc" id="L24">public class Tasks {</span>

<span class="nc" id="L26">	private static final Logger LOG = LoggerFactory.getLogger(Tasks.class);</span>

	public static &lt;T&gt; TaskBuilder&lt;T&gt; create(Callable&lt;T&gt; callable) {
<span class="nc" id="L29">		return new TaskBuilder&lt;&gt;(callable);</span>
	}

	public static TaskBuilder&lt;Void&gt; create(VoidCallable callable) {
<span class="nc" id="L33">		return create(() -&gt; {</span>
<span class="nc" id="L34">			callable.call();</span>
<span class="nc" id="L35">			return null;</span>
		});
	}

	public static class TaskBuilder&lt;T&gt; {

		private final Callable&lt;T&gt; callable;
<span class="nc" id="L42">		private Consumer&lt;T&gt; successHandler = x -&gt; {</span>
<span class="nc" id="L43">		};</span>
<span class="nc" id="L44">		private List&lt;ErrorHandler&lt;?&gt;&gt; errorHandlers = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L45">		private Runnable finallyHandler = () -&gt; {};</span>

<span class="nc" id="L47">		TaskBuilder(Callable&lt;T&gt; callable) {</span>
<span class="nc" id="L48">			this.callable = callable;</span>
<span class="nc" id="L49">		}</span>

		public TaskBuilder&lt;T&gt; onSuccess(Runnable successHandler) {
<span class="nc" id="L52">			this.successHandler = x -&gt; {</span>
<span class="nc" id="L53">				successHandler.run();</span>
<span class="nc" id="L54">			};</span>
<span class="nc" id="L55">			return this;</span>
		}

		public TaskBuilder&lt;T&gt; onSuccess(Consumer&lt;T&gt; successHandler) {
<span class="nc" id="L59">			this.successHandler = successHandler;</span>
<span class="nc" id="L60">			return this;</span>
		}

		public &lt;E extends Throwable&gt; TaskBuilder&lt;T&gt; onError(Class&lt;E&gt; type, Consumer&lt;E&gt; exceptionHandler) {
<span class="nc" id="L64">			errorHandlers.add(new ErrorHandler&lt;&gt;(type, exceptionHandler));</span>
<span class="nc" id="L65">			return this;</span>
		}

		public TaskBuilder&lt;T&gt; andFinally(Runnable finallyHandler) {
<span class="nc" id="L69">			this.finallyHandler = finallyHandler;</span>
<span class="nc" id="L70">			return this;</span>
		}

		private Task&lt;T&gt; build() {
<span class="nc" id="L74">			return new TaskImpl&lt;&gt;(callable, successHandler, errorHandlers, finallyHandler);</span>
		}

		public Task&lt;T&gt; runOnce(ExecutorService executor) {
<span class="nc" id="L78">			Task&lt;T&gt; task = build();</span>
<span class="nc" id="L79">			executor.submit(task);</span>
<span class="nc" id="L80">			return task;</span>
		}

		public Task&lt;T&gt; scheduleOnce(ScheduledExecutorService scheduler, long delay, TimeUnit unit) {
<span class="nc" id="L84">			Task&lt;T&gt; task = build();</span>
<span class="nc" id="L85">			scheduler.schedule(task, delay, unit);</span>
<span class="nc" id="L86">			return task;</span>
		}

		public ScheduledService&lt;T&gt; schedulePeriodically(ExecutorService executor, Duration initialDelay, Duration period) {
<span class="nc" id="L90">			ScheduledService&lt;T&gt; service = new RestartingService&lt;&gt;(this::build);</span>
<span class="nc" id="L91">			service.setExecutor(executor);</span>
<span class="nc" id="L92">			service.setDelay(initialDelay);</span>
<span class="nc" id="L93">			service.setPeriod(period);</span>
<span class="nc" id="L94">			Platform.runLater(service::start);</span>
<span class="nc" id="L95">			return service;</span>
		}

	}

	private static class ErrorHandler&lt;ErrorType extends Throwable&gt; {

		private final Class&lt;ErrorType&gt; type;
		private final Consumer&lt;ErrorType&gt; errorHandler;

<span class="nc" id="L105">		public ErrorHandler(Class&lt;ErrorType&gt; type, Consumer&lt;ErrorType&gt; errorHandler) {</span>
<span class="nc" id="L106">			this.type = type;</span>
<span class="nc" id="L107">			this.errorHandler = errorHandler;</span>
<span class="nc" id="L108">		}</span>

		public boolean handles(Throwable error) {
<span class="nc" id="L111">			return type.isInstance(error);</span>
		}

		public void handle(Throwable error) throws ClassCastException {
<span class="nc" id="L115">			ErrorType typedError = type.cast(error);</span>
<span class="nc" id="L116">			errorHandler.accept(typedError);</span>
<span class="nc" id="L117">		}</span>

	}

	/**
	 * Adapter between java.util.function.* and javafx.concurrent.*
	 */
	private static class TaskImpl&lt;T&gt; extends Task&lt;T&gt; {

		private final Callable&lt;T&gt; callable;
		private final Consumer&lt;T&gt; successHandler;
		private List&lt;ErrorHandler&lt;?&gt;&gt; errorHandlers;
		private final Runnable finallyHandler;

<span class="nc" id="L131">		TaskImpl(Callable&lt;T&gt; callable, Consumer&lt;T&gt; successHandler, List&lt;ErrorHandler&lt;?&gt;&gt; errorHandlers, Runnable finallyHandler) {</span>
<span class="nc" id="L132">			this.callable = callable;</span>
<span class="nc" id="L133">			this.successHandler = successHandler;</span>
<span class="nc" id="L134">			this.errorHandlers = errorHandlers;</span>
<span class="nc" id="L135">			this.finallyHandler = finallyHandler;</span>
<span class="nc" id="L136">		}</span>

		@Override
		protected T call() throws Exception {
<span class="nc" id="L140">			return callable.call();</span>
		}

		@Override
		protected void succeeded() {
			try {
<span class="nc" id="L146">				successHandler.accept(getValue());</span>
			} finally {
<span class="nc" id="L148">				finallyHandler.run();</span>
			}
<span class="nc" id="L150">		}</span>

		@Override
		protected void failed() {
			try {
<span class="nc" id="L155">				Throwable exception = getException();</span>
<span class="nc" id="L156">				errorHandlers.stream().filter(handler -&gt; handler.handles(exception)).findFirst().ifPresentOrElse(exceptionHandler -&gt; {</span>
<span class="nc" id="L157">					exceptionHandler.handle(exception);</span>
<span class="nc" id="L158">				}, () -&gt; {</span>
<span class="nc" id="L159">					LOG.error(&quot;Unhandled exception&quot;, exception);</span>
<span class="nc" id="L160">				});</span>
			} finally {
<span class="nc" id="L162">				finallyHandler.run();</span>
			}
<span class="nc" id="L164">		}</span>

	}

	/**
	 * A service that keeps executing the next task long as tasks are succeeding.
	 */
	private static class RestartingService&lt;T&gt; extends ScheduledService&lt;T&gt; {

		private final Supplier&lt;Task&lt;T&gt;&gt; taskFactory;

<span class="nc" id="L175">		RestartingService(Supplier&lt;Task&lt;T&gt;&gt; taskFactory) {</span>
<span class="nc" id="L176">			this.taskFactory = taskFactory;</span>

<span class="nc" id="L178">			setOnFailed(event -&gt; LOG.error(&quot;Failed to execute service&quot;, getException()));</span>
<span class="nc" id="L179">		}</span>

		@Override
		protected Task&lt;T&gt; createTask() {
<span class="nc" id="L183">			return taskFactory.get();</span>
		}

	}

	public interface VoidCallable {

		void call() throws Exception;

	}

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>