<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WordEncoder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cryptomator Desktop App</a> &gt; <a href="index.source.html" class="el_package">org.cryptomator.ui.recoverykey</a> &gt; <span class="el_source">WordEncoder.java</span></div><h1>WordEncoder.java</h1><pre class="source lang-java linenums">package org.cryptomator.ui.recoverykey;

import com.google.common.base.Preconditions;
import com.google.common.base.Splitter;
import com.google.common.base.Strings;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

<span class="fc" id="L20">@Singleton</span>
class WordEncoder {

	private static final String DEFAULT_WORD_FILE = &quot;/i18n/4096words_en.txt&quot;;
	private static final int WORD_COUNT = 4096;
	private static final char DELIMITER = ' ';

	private final List&lt;String&gt; words;
	private final Map&lt;String, Integer&gt; indices;

	@Inject
	public WordEncoder() {
<span class="fc" id="L32">		this(DEFAULT_WORD_FILE);</span>
<span class="fc" id="L33">	}</span>

	public List&lt;String&gt; getWords() {
<span class="nc" id="L36">		return words;</span>
	}

<span class="fc" id="L39">	public WordEncoder(String wordFile) {</span>
<span class="fc" id="L40">		try (InputStream in = getClass().getResourceAsStream(wordFile); //</span>
<span class="fc" id="L41">			 Reader reader = new InputStreamReader(in, StandardCharsets.US_ASCII.newDecoder()); //</span>
<span class="fc" id="L42">			 BufferedReader bufferedReader = new BufferedReader(reader)) {</span>
<span class="fc" id="L43">			this.words = bufferedReader.lines().limit(WORD_COUNT).collect(Collectors.toUnmodifiableList());</span>
<span class="nc" id="L44">		} catch (IOException e) {</span>
<span class="nc" id="L45">			throw new IllegalArgumentException(&quot;Unreadable file: &quot; + wordFile, e);</span>
<span class="fc" id="L46">		}</span>
<span class="pc bpc" id="L47" title="1 of 2 branches missed.">		if (words.size() &lt; WORD_COUNT) {</span>
<span class="nc" id="L48">			throw new IllegalArgumentException(&quot;Insufficient input file: &quot; + wordFile);</span>
		}
<span class="fc" id="L50">		this.indices = Map.ofEntries(IntStream.range(0, WORD_COUNT).mapToObj(i -&gt; Map.entry(words.get(i), i)).toArray(Map.Entry[]::new));</span>
<span class="fc" id="L51">	}</span>

	/**
	 * Encodes the given input as a sequence of words.
	 *
	 * @param input A multiple of three bytes
	 * @return A String that can be {@link #decode(String) decoded} to the input again.
	 * @throws IllegalArgumentException If input is not a multiple of three bytes
	 */
	public String encodePadded(byte[] input) {
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">		Preconditions.checkArgument(input.length % 3 == 0, &quot;input needs to be padded to a multiple of three&quot;);</span>
<span class="fc" id="L62">		StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">		for (int i = 0; i &lt; input.length; i += 3) {</span>
<span class="fc" id="L64">			byte b1 = input[i];</span>
<span class="fc" id="L65">			byte b2 = input[i + 1];</span>
<span class="fc" id="L66">			byte b3 = input[i + 2];</span>
<span class="fc" id="L67">			int firstWordIndex = (0xFF0 &amp; (b1 &lt;&lt; 4)) + (0x00F &amp; (b2 &gt;&gt; 4)); // 0xFFF000</span>
<span class="fc" id="L68">			int secondWordIndex = (0xF00 &amp; (b2 &lt;&lt; 8)) + (0x0FF &amp; b3); // 0x000FFF</span>
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">			assert firstWordIndex &lt; WORD_COUNT;</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">			assert secondWordIndex &lt; WORD_COUNT;</span>
<span class="fc" id="L71">			sb.append(words.get(firstWordIndex)).append(DELIMITER);</span>
<span class="fc" id="L72">			sb.append(words.get(secondWordIndex)).append(DELIMITER);</span>
		}
<span class="fc bfc" id="L74" title="All 2 branches covered.">		if (sb.length() &gt; 0) {</span>
<span class="fc" id="L75">			sb.setLength(sb.length() - 1); // remove last space</span>
		}
<span class="fc" id="L77">		return sb.toString();</span>
	}

	/**
	 * Decodes a String that has previously been {@link #encodePadded(byte[]) encoded} to a word sequence.
	 *
	 * @param encoded The word sequence
	 * @return Decoded bytes
	 * @throws IllegalArgumentException If the encoded string doesn't consist of a multiple of two words or one of the words is unknown to this encoder.
	 */
	public byte[] decode(String encoded) {
<span class="fc" id="L88">		List&lt;String&gt; split = Splitter.on(DELIMITER).omitEmptyStrings().splitToList(Strings.nullToEmpty(encoded));</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">		Preconditions.checkArgument(split.size() % 2 == 0, &quot;%s needs to be a multiple of two words&quot;, encoded);</span>
<span class="fc" id="L90">		byte[] result = new byte[split.size() / 2 * 3];</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">		for (int i = 0; i &lt; split.size(); i += 2) {</span>
<span class="fc" id="L92">			String w1 = split.get(i);</span>
<span class="fc" id="L93">			String w2 = split.get(i + 1);</span>
<span class="fc" id="L94">			int firstWordIndex = indices.getOrDefault(w1, -1);</span>
<span class="fc" id="L95">			int secondWordIndex = indices.getOrDefault(w2, -1);</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">			Preconditions.checkArgument(firstWordIndex != -1, &quot;%s not in dictionary&quot;, w1);</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">			Preconditions.checkArgument(secondWordIndex != -1, &quot;%s not in dictionary&quot;, w2);</span>
<span class="fc" id="L98">			byte b1 = (byte) (0xFF &amp; (firstWordIndex &gt;&gt; 4));</span>
<span class="fc" id="L99">			byte b2 = (byte) ((0xF0 &amp; (firstWordIndex &lt;&lt; 4)) + (0x0F &amp; (secondWordIndex &gt;&gt; 8)));</span>
<span class="fc" id="L100">			byte b3 = (byte) (0xFF &amp; secondWordIndex);</span>
<span class="fc" id="L101">			result[i / 2 * 3] = b1;</span>
<span class="fc" id="L102">			result[i / 2 * 3 + 1] = b2;</span>
<span class="fc" id="L103">			result[i / 2 * 3 + 2] = b3;</span>
		}
<span class="fc" id="L105">		return result;</span>
	}


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>