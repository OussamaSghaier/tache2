<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RecoveryKeyFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cryptomator Desktop App</a> &gt; <a href="index.source.html" class="el_package">org.cryptomator.ui.recoverykey</a> &gt; <span class="el_source">RecoveryKeyFactory.java</span></div><h1>RecoveryKeyFactory.java</h1><pre class="source lang-java linenums">package org.cryptomator.ui.recoverykey;

import com.google.common.base.Preconditions;
import com.google.common.hash.Hashing;
import org.cryptomator.cryptofs.common.BackupHelper;
import org.cryptomator.cryptolib.api.CryptoException;
import org.cryptomator.cryptolib.api.InvalidPassphraseException;
import org.cryptomator.cryptolib.api.Masterkey;
import org.cryptomator.cryptolib.common.MasterkeyFileAccess;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.Arrays;
import java.util.Collection;
import java.util.function.Predicate;

import static org.cryptomator.common.Constants.MASTERKEY_BACKUP_SUFFIX;
import static org.cryptomator.common.Constants.MASTERKEY_FILENAME;

@Singleton
public class RecoveryKeyFactory {

	private final WordEncoder wordEncoder;
	private final MasterkeyFileAccess masterkeyFileAccess;

	@Inject
<span class="fc" id="L33">	public RecoveryKeyFactory(WordEncoder wordEncoder, MasterkeyFileAccess masterkeyFileAccess) {</span>
<span class="fc" id="L34">		this.wordEncoder = wordEncoder;</span>
<span class="fc" id="L35">		this.masterkeyFileAccess = masterkeyFileAccess;</span>
<span class="fc" id="L36">	}</span>

	public Collection&lt;String&gt; getDictionary() {
<span class="nc" id="L39">		return wordEncoder.getWords();</span>
	}

	/**
	 * @param vaultPath Path to the storage location of a vault
	 * @param password The vault's password
	 * @return The recovery key of the vault at the given path
	 * @throws IOException If the masterkey file could not be read
	 * @throws InvalidPassphraseException If the provided password is wrong
	 * @throws CryptoException In case of other cryptographic errors
	 * @apiNote This is a long-running operation and should be invoked in a background thread
	 */
	public String createRecoveryKey(Path vaultPath, CharSequence password) throws IOException, InvalidPassphraseException, CryptoException {
<span class="fc" id="L52">		Path masterkeyPath = vaultPath.resolve(MASTERKEY_FILENAME);</span>
<span class="fc" id="L53">		byte[] rawKey = new byte[0];</span>
<span class="fc" id="L54">		try (var masterkey = masterkeyFileAccess.load(masterkeyPath, password)) {</span>
<span class="fc" id="L55">			rawKey = masterkey.getEncoded();</span>
<span class="fc" id="L56">			return createRecoveryKey(rawKey);</span>
		} finally {
<span class="fc" id="L58">			Arrays.fill(rawKey, (byte) 0x00);</span>
		}
	}

	@VisibleForTesting
	String createRecoveryKey(byte[] rawKey) {
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">		Preconditions.checkArgument(rawKey.length == 64, &quot;key should be 64 bytes&quot;);</span>
<span class="fc" id="L65">		byte[] paddedKey = Arrays.copyOf(rawKey, 66);</span>
		try {
			// copy 16 most significant bits of CRC32(rawKey) to the end of paddedKey:
<span class="fc" id="L68">			Hashing.crc32().hashBytes(rawKey).writeBytesTo(paddedKey, 64, 2);</span>
<span class="fc" id="L69">			return wordEncoder.encodePadded(paddedKey);</span>
		} finally {
<span class="fc" id="L71">			Arrays.fill(paddedKey, (byte) 0x00);</span>
		}
	}

	/**
	 * Creates a completely new masterkey using a recovery key.
	 *
	 * @param vaultPath Path to the storage location of a vault
	 * @param recoveryKey A recovery key for this vault
	 * @param newPassword The new password used to encrypt the keys
	 * @throws IOException If the masterkey file could not be written
	 * @throws IllegalArgumentException If the recoveryKey is invalid
	 * @apiNote This is a long-running operation and should be invoked in a background thread
	 */
	public void newMasterkeyFileWithPassphrase(Path vaultPath, String recoveryKey, CharSequence newPassword) throws IOException, IllegalArgumentException {
<span class="nc" id="L86">		final byte[] rawKey = decodeRecoveryKey(recoveryKey);</span>
<span class="nc" id="L87">		try (var masterkey = new Masterkey(rawKey)) {</span>
<span class="nc" id="L88">			Path masterkeyPath = vaultPath.resolve(MASTERKEY_FILENAME);</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">			if (Files.exists(masterkeyPath)) {</span>
<span class="nc" id="L90">				byte[] oldMasterkeyBytes = Files.readAllBytes(masterkeyPath);</span>
				// TODO: deduplicate with ChangePasswordController:
<span class="nc" id="L92">				Path backupKeyPath = vaultPath.resolve(MASTERKEY_FILENAME + BackupHelper.generateFileIdSuffix(oldMasterkeyBytes) + MASTERKEY_BACKUP_SUFFIX);</span>
<span class="nc" id="L93">				Files.move(masterkeyPath, backupKeyPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);</span>
			}
<span class="nc" id="L95">			masterkeyFileAccess.persist(masterkey, masterkeyPath, newPassword);</span>
		} finally {
<span class="nc" id="L97">			Arrays.fill(rawKey, (byte) 0x00);</span>
		}
<span class="nc" id="L99">	}</span>

	/**
	 * Checks whether a String is a syntactically correct recovery key with a valid checksum
	 *
	 * @param recoveryKey A word sequence which might be a recovery key
	 * @return &lt;code&gt;true&lt;/code&gt; if this seems to be a legitimate recovery key
	 */
	public boolean validateRecoveryKey(String recoveryKey) {
<span class="fc" id="L108">		return validateRecoveryKey(recoveryKey, null);</span>
	}

	/**
	 * Checks whether a String is a syntactically correct recovery key with a valid checksum and passes the extended validation.
	 *
	 * @param recoveryKey A word sequence which might be a recovery key
	 * @param extendedValidation Additional verification of the decoded key (optional)
	 * @return &lt;code&gt;true&lt;/code&gt; if this seems to be a legitimate recovery key and passes the extended validation
	 */
	public boolean validateRecoveryKey(String recoveryKey, @Nullable Predicate&lt;byte[]&gt; extendedValidation) {
<span class="fc" id="L119">		byte[] key = new byte[0];</span>
		try {
<span class="fc" id="L121">			key = decodeRecoveryKey(recoveryKey);</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">			if (extendedValidation != null) {</span>
<span class="fc" id="L123">				return extendedValidation.test(key);</span>
			} else {
<span class="fc" id="L125">				return true;</span>
			}
<span class="fc" id="L127">		} catch (IllegalArgumentException e) {</span>
<span class="fc" id="L128">			return false;</span>
		} finally {
<span class="fc" id="L130">			Arrays.fill(key, (byte) 0x00);</span>
		}
	}

	private byte[] decodeRecoveryKey(String recoveryKey) throws IllegalArgumentException {
<span class="fc" id="L135">		byte[] paddedKey = new byte[0];</span>
		try {
<span class="fc" id="L137">			paddedKey = wordEncoder.decode(recoveryKey);</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">			Preconditions.checkArgument(paddedKey.length == 66, &quot;Recovery key doesn't consist of 66 bytes.&quot;);</span>
<span class="fc" id="L139">			byte[] rawKey = Arrays.copyOf(paddedKey, 64);</span>
<span class="fc" id="L140">			byte[] expectedCrc16 = Arrays.copyOfRange(paddedKey, 64, 66);</span>
<span class="fc" id="L141">			byte[] actualCrc32 = Hashing.crc32().hashBytes(rawKey).asBytes();</span>
<span class="fc" id="L142">			byte[] actualCrc16 = Arrays.copyOf(actualCrc32, 2);</span>
<span class="fc" id="L143">			Preconditions.checkArgument(Arrays.equals(expectedCrc16, actualCrc16), &quot;Recovery key has invalid CRC.&quot;);</span>
<span class="fc" id="L144">			return rawKey;</span>
		} finally {
<span class="fc" id="L146">			Arrays.fill(paddedKey, (byte) 0x00);</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>